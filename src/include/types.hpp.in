#ifndef GRAPH_UTILITIES_TYPES
#define GRPAH_UTILITIES_TYPES


/*!
 * \file types.hpp
 *
 * \brief Types used by the GraphUtilities library.
 */


///////////////////////
// Enumeration types //
///////////////////////

/*!
 * \brief Available methods for indexing nodes of a graph.
 *
 * Defines the existing methods for indexing nodes of a graph:
 * \li \b ShortIndexing Performs one forward and one backward post-order
 * labeling
 * \li \b SuccessorOrder Sorts the successors of each node during a first
 * forward post-order labeling before performing a second backward post-order
 * labeling
 * \li \b Standard Reorders predecessors of each node during a first forward
 * post-order labeling by the order of their visits and does the same for
 * successors during a second backward post-order labeling.
 * \li \b LabelOrder After performing a \b Standard labeling each node has its
 * predecessors and successors ordered by their labels.
 *
 * \sa Graph::setIndexMethod() and Graph::getIndexMethod()
 */
typedef enum {
  ShortIndexing = 0x00,
  SuccessorOrder = 0x02,
  Standard = 0x03,
  LabelOrder = 0x07,
  UndefinedIndexMethod = 0x10
} IndexMethod;


/*!
 * \brief Available methods for path searching during reachability queries.
 *
 * Defines the existing methods for searching paths within a graph:
 * \li \b DFS Performs a Depth-First-Search from the source node on the subgraph
 * defined by the pre-indexed node labels
 * \li \b BBFS Performs a Bidirectional-Breadth-First-Search from the source and
 * target nodes on the subgraph defined by the pre-indexed node labels
 * \li \b NoLabels Performs a Depth-First-Search from the source node on the
 * whole graph thereby disregarding any existing pre-indexed node labels
 *
 * \sa createRQuery()
 */
typedef enum {
  DFS,
  BBFS,
  NoLabels,
  UndefinedSearchMethod
} SearchMethod;


/*!
 * \brief Available methods for partioning a graph.
 *
 * Defines the existing methods for partioning a graph:
 * \li \b Convexify Uses recursive bisection steps comprised of a non-convex
 * bisection performed with the PaToH library followed by a convexification of
 * the obtained bisection.
 * \li \b MaxDistance Performs recursive bisection steps based on critical path
 * lengths. For a given partition the maximum lengths of paths from sources and
 * to sinks are computed for each node. The bisection is done by taking nodes
 * with a shorter longest-path from sources than their longest-path to sinks one
 * on side and the other nodes on the other side. Before performing such a
 * bisection the partition is verified for connectivity. If the partition is not
 * connex then a straightforward multi-section is done between the
 * connex-compononents of the partition.
 *
 * \sa createPQuery()
 */
typedef enum {
  Convexify,
  MaxDistance,
  UndefinedPartitionMethod
} PartitionMethod;


/*!
 * \brief Available methods for coarsening a graph.
 *
 * Currently only \b Greedy coarsening is available. Other methods are under
 * development.
 *
 * \sa createCQuery()
 */
typedef enum {
  Greedy,
  UndefinedCoarsenMethod
} CoarsenMethod;


/*!
 * \brief Available types for IO complexity evaluation of Partition instances
 *
 * Defines the available computations for IO complexity:
 * \li TotalLoads Counts only the number of loads generated by communications
 * within the code between memory resident partitions. This excludes the load of
 * input data. Stores are ignored on the whole.
 * \li AvgLoadStore Counts the average number of loads and stores per vertex of
 * the graph.
 *
 * \sa Graph::getPartitionCost()
 */
typedef enum {
  TotalLoads,
  AvgLoadStore,
  UndefinedIOType
} IOComplexityType;

#endif // GRAPH_UTILITIES_TYPES
