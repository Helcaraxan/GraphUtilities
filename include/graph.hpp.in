/*
 * graph.hpp
 */

/* Forward declarations */
class Edge;
class Vertex;
class Graph;


#ifndef GRAPH_HPP
#define GRAPH_HPP

#include <list>
#include <vector>
#include <pthread.h>
#include <semaphore.h>

// Let cmake choose which options are enabled
#cmakedefine ENABLE_RETRO_LABELS
#cmakedefine ENABLE_STATISTICS
#cmakedefine ENABLE_BENCHMARKS

// Let cmake choose the maximum number of parallel queries
#define MAX_THREADS ${MAX_THREADS}


using namespace std;


// Function used as the base of a query thread
struct QueryWorkerArgs {
  Graph * graphArg;
  int threadIdArg;

  QueryWorkerArgs(Graph * graph, int threadId) :
    graphArg(graph),
    threadIdArg(threadId)
  {}
};

void * queryWorker(void * args);


// The Graph classes

class Vertex;
class Graph;


// Class declarations

class Vertex {
friend class Graph;

// Local types
public:
  typedef vector<Vertex *>::iterator iterator;

// Data members
public:
  int id;

private:
  int orderLabel = -1;
  int reverseOrderLabel = -1;
#ifdef ENABLE_RETRO_LABELS
  int retroOrderLabel = -1;
  int retroReverseOrderLabel = -1;
#endif // ENABLE_RETRO_LABELS

  int inVisits = 0;
  int outVisits = 0;
  int DFSId[MAX_THREADS] = {0};

  Vertex * firstVisit = NULL;

  int predecessorCount = 0;
  int successorCount = 0;
  vector<Vertex *> predecessors;
  vector<Vertex *> successors;

// Function members
public:
  // Constructors & Destructor
  Vertex(int i) :
    id(i)
  {}

  ~Vertex(void) {
    for (auto it = predecessors.begin(), end = predecessors.end(); it != end; ++it)
      (*it)->removeSuccessor(this);

    for (auto it = successors.begin(), end = successors.end(); it != end; ++it)
      (*it)->removePredecessor(this);
  }

  // Modificators
  bool addPredecessor(Vertex * pred);
  bool addSuccessor(Vertex * succ);
  bool removePredecessor(Vertex * pred);
  bool removeSuccessor(Vertex * succ);

  // Access
  int getNumberOfPredecessors(void);
  int getNumberOfSuccessors(void);

  // Iterators
  iterator predecessors_begin(void);
  iterator predecessors_end(void);

  iterator successors_begin(void);
  iterator successors_end(void);

private:
  // Indexing
  void visit(Vertex * pred, int method);
  Vertex * createPostOrder(vector<Vertex *> * postOrder, int method);
};


class Graph {
friend void * queryWorker(void * args);

// Local types
public:
  /* The IndexMethod values obey the following rules:
   * 0x01 (first bit) Indicates if predecessors are rescheduled on traversal
   * 0x02 (second bit) Indicates if successors are rescheduled on traversal
   * 0x04 (third bit) Indicates if successors are ordered with their labels
   */
  typedef enum {
    ShortIndexing = 0x00,
    SuccessorOrder = 0x02,
    Standard = 0x03,
    LabelOrder = 0x07,
    UndefinedMethod = 0x10
  } IndexMethod;


  typedef enum {
    DFS,
    BBFS,
    NoLabels,
    Undefined
  } SearchMethod;


  class Query {
  friend class Graph;
  friend void * queryWorker(void * args);

  // Data members
  private:
    Vertex * source;
    Vertex * target;
    bool answer = false;
    bool error = false;
    bool cancel = false;
    bool internal = false;
    long long searchTime = 0;
    Graph::SearchMethod method = Undefined;

#ifdef ENABLE_STATISTICS
	vector<Vertex *> path;
	uintmax_t searchedNodes = 0;
#endif // ENABLE_STATISTICS

  // Function members
  public:
    Query(Vertex * u, Vertex * v, SearchMethod searchMethod = Undefined) {
      source = u;
      target = v;
      method = searchMethod;
    }

    Vertex * getSource(void);
    Vertex * getTarget(void);
    bool getAnswer(void);
    bool isError(void);
  };


// Data members
protected:
  bool indexed = false;
  bool condensed = false;
  IndexMethod indexMethod = UndefinedMethod;
  unsigned int edgeCount = 0;

  vector<Vertex *> vertices;
  vector<Vertex *> sources;
  vector<Vertex *> sinks;

  // Global IDs to distinguish between seperate DFSs
  unsigned char DFSId[MAX_THREADS] = {0};

private:
  // Indexing
  pthread_mutex_t indexMutex;

  // Queries
  pthread_mutex_t methodMutex;
  pthread_mutex_t jobMutex;
  sem_t jobSemaphore;
  list<Query *> jobQueue;
  volatile SearchMethod preferredMethod = Undefined;
  volatile int DFSwin = 0;
  volatile int BBFSwin = 0;

  // Results
  pthread_mutex_t resultMutex;
  pthread_mutex_t internalResultMutex;
  sem_t resultSemaphore;
  sem_t internalResultSemaphore;
  list<Query *> resultQueue;
  list<Query *> internalResultQueue;

  // Reordering vectors
  vector<Vertex *> successorQueue;
  vector<Vertex *> predecessorQueue;

  // Multi-threading
  bool threadShutdown = false;
  volatile int activeThreads = 0;
  volatile bool noQueries = false;
  pthread_mutex_t queryWaitMutex;
  pthread_mutex_t globalWaitMutex;
  pthread_cond_t queryWaitCondition;
  pthread_cond_t globalWaitCondition;
  pthread_t queryThreads[MAX_THREADS];

#ifdef ENABLE_STATISTICS
  // Counters
  volatile uintmax_t queryCount{0};
  volatile uintmax_t positiveQueryCount{0};
  volatile uintmax_t negativeQueryCount{0};
  volatile uintmax_t shortNegativeQueryCount{0};

  // DFS overhead statistics
  pthread_mutex_t statisticsMutex;
  double positiveQueryOverhead = 0.0L;
  double negativeQueryOverhead = 0.0L;
#endif // ENABLE_STATISTICS

#ifdef ENABLE_BENCHMARKS
  // Counters
  volatile long long queryNumber{0};
  volatile long long cyclesSpentIndexing{0};
  volatile long long cyclesSpentQuerying{0};
  volatile long long graphMemoryUsage{0};

  pthread_mutex_t benchmarkMutex;
#endif // ENABLE_BENCHMARKS

// Function members
public:
  // Constructors & Destructor
  Graph(void) {
    pthread_mutex_init(&indexMutex, NULL);
	pthread_mutex_init(&methodMutex, NULL);
    pthread_mutex_init(&jobMutex, NULL);
    pthread_mutex_init(&resultMutex, NULL);
    pthread_mutex_init(&internalResultMutex, NULL);
    pthread_mutex_init(&queryWaitMutex, NULL);
    pthread_mutex_init(&globalWaitMutex, NULL);
#ifdef ENABLE_STATISTICS
    pthread_mutex_init(&statisticsMutex, NULL);
#endif // ENABLE_STATISTICS
#ifdef ENABLE_BENCHMARKS
	pthread_mutex_init(&benchmarkMutex, NULL);
#endif // ENABLE_BENCHMARKS
    sem_init(&jobSemaphore, 0, 0);
    sem_init(&resultSemaphore, 0, 0);
    sem_init(&internalResultSemaphore, 0, 0);
	pthread_cond_init(&queryWaitCondition, NULL);
	pthread_cond_init(&globalWaitCondition, NULL);
	
    for (int i = 0; i < MAX_THREADS; i++) {
      QueryWorkerArgs * args = new QueryWorkerArgs(this, i);
      pthread_create(&queryThreads[i], NULL, &queryWorker, (void *) args);
    }
  }

  ~Graph(void) {
    threadShutdown = true;

    for (int i = 0; i < MAX_THREADS; i++)
      sem_post(&jobSemaphore);

    for (int i = 0; i < MAX_THREADS; i++)
      pthread_join(queryThreads[i], NULL);

    for (auto it = jobQueue.begin(), end = jobQueue.end(); it != end; ++it)
      (*it)->error = true;

    for (auto it = vertices.begin(), end = vertices.end(); it != end; ++it)
      delete *it;

	pthread_mutex_destroy(&indexMutex);
	pthread_mutex_destroy(&methodMutex);
	pthread_mutex_destroy(&jobMutex);
	pthread_mutex_destroy(&resultMutex);
	pthread_mutex_destroy(&internalResultMutex);
	pthread_mutex_destroy(&queryWaitMutex);
	pthread_mutex_destroy(&globalWaitMutex);
#ifdef ENABLE_STATISTICS
	pthread_mutex_destroy(&statisticsMutex);
#endif // ENABLE_STATISTICS
#ifdef ENABLE_BENCHMARKS
	pthread_mutex_destroy(&benchmarkMutex);
#endif // ENABLE_BENCHMARKS
	sem_destroy(&jobSemaphore);
	sem_destroy(&resultSemaphore);
	sem_destroy(&internalResultSemaphore);
	pthread_cond_destroy(&queryWaitCondition);
	pthread_cond_destroy(&globalWaitCondition);
  }

  // Parser functions
  static Graph * createFromDotFile(const char * fileName, bool noDoubleEdges = false);
  static Graph * createFromGraFile(const char * fileName, bool noDoubleEdges = false);

  // Modificators
  Vertex * addVertex(void);
  void removeVertex(Vertex * v);
  void mergeVertices(Vertex * s, Vertex * t);
  bool addEdge(Vertex * s, Vertex * t);
  bool removeEdge(Vertex * s, Vertex * t);
  void setIndexMethod(IndexMethod newMethod);

  // Access
  unsigned int getEdgeCount(void);
  unsigned int getVertexCount(void);
  Vertex * getVertexFromId(int id);
  IndexMethod getIndexMethod(void);

  // Queries
  void pushQuery(Query * query);
  Query * pullResult(void);
  void endOfQueries(void);

  // Statistics
  bool statisticsAreEnabled(void);
  uintmax_t getQueryCount(void);
  uintmax_t getPositiveQueryCount(void);
  uintmax_t getNegativeQueryCount(void);
  uintmax_t getShortNegativeQueryCount(void);
  double getPositiveQueryOverhead(void);
  double getNegativeQueryOverhead(void);
  void printStatistics(ostream &os);

  // Benchmarking
  bool benchmarksAreEnabled(void);
  long long getQueryNumber(void);
  long long getCyclesSpentIndexing(void);
  long long getCyclesSpentQuerying(void);
  void printBenchmarks(ostream &os);

protected:
  // Indexing
  void labelVertices(bool retro, bool reverse);
  void indexGraph(void);

  // Maintenance
  void discoverExtremities(void);
  void condenseGraph(void);

  // Multi-threading
  void startQuery(void);
  void stopQuery(void);
  void startGlobalOperation(void);
  void stopGlobalOperation(void);

private:
  // Maintenance
  void condenseFromSource(Vertex * source);
  Vertex * addVertexUnsafe(void);
  bool addEdgeUnsafe(Vertex * source, Vertex * target);

  // Internal query functions
  void * areConnectedDFS(void * arg);
  void * areConnectedBBFS(void * arg);
  void * areConnectedNoLabels(void * arg);
  void checkIdOverflow(void);

#ifdef ENABLE_STATISTICS
  // Internal statistic maintenance
  void registerQueryStatistics(Query * query);
#endif // ENABLE_STATISTICS
};

#endif // GRAPH_HPP
